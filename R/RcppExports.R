# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Enhance network directionality with C++ acceleration
#' 
#' @param X Network adjacency matrix
#' @param lambda Directionality parameter (0 to 1)
#' @return Enhanced network matrix
#' @export
strictDirectionCpp <- function(XSEXP, lambda = 1.0) {
    .Call(`_scTenifoldKnk_strictDirectionCpp`, XSEXP, lambda)
}

#' Perform virtual knockout on network
#' 
#' @param network Gene regulatory network matrix
#' @param geneIdx Index of gene to knockout (0-based)
#' @return Network with gene knocked out
#' @export
knockoutGeneCpp <- function(networkSEXP, geneIdx) {
    .Call(`_scTenifoldKnk_knockoutGeneCpp`, networkSEXP, geneIdx)
}

#' Convert sparse matrix to dense and transpose
#' 
#' @param X Sparse matrix
#' @return Dense transposed matrix
#' @export
sparseToDenseTranspose <- function(XSEXP) {
    .Call(`_scTenifoldKnk_sparseToDenseTranspose`, XSEXP)
}

#' Differential regulation analysis with C++ acceleration
#' 
#' @param manifoldOutput Matrix with WT and KO gene embeddings (2*nGenes x d)
#' @param geneNames Vector of gene names
#' @param gKO Name of knocked out gene
#' @return DataFrame with differential regulation statistics
#' @export
dRegulationCpp <- function(manifoldOutputSEXP, geneNames, gKO) {
    .Call(`_scTenifoldKnk_dRegulationCpp`, manifoldOutputSEXP, geneNames, gKO)
}

#' Build multiple gene regulatory networks with C++ acceleration
#' 
#' @param countMatrix Gene expression matrix (genes x cells)
#' @param nNet Number of networks to generate
#' @param nCells Number of cells to subsample for each network
#' @param nComp Number of principal components
#' @param q Quantile threshold for edge filtering
#' @param scaleScores Whether to scale network weights to [-1, 1]
#' @param symmetric Whether to make networks symmetric
#' @param nThreads Number of threads (0 = auto)
#' @return List of networks
#' @export
makeNetworksCpp <- function(countMatrixSEXP, nNet = 10L, nCells = 500L, nComp = 3L, q = 0.9, scaleScores = TRUE, symmetric = FALSE, nThreads = 0L) {
    .Call(`_scTenifoldKnk_makeNetworksCpp`, countMatrixSEXP, nNet, nCells, nComp, q, scaleScores, symmetric, nThreads)
}

#' CP Tensor Decomposition with C++ acceleration
#' 
#' @param networkList List of network matrices
#' @param K Rank of decomposition
#' @param maxIter Maximum iterations
#' @param maxError Convergence threshold
#' @param nDecimal Decimal places for output
#' @return List with reconstructed network and factors
#' @export
tensorDecompositionCpp <- function(networkList, K = 3L, maxIter = 1000L, maxError = 1e-5, nDecimal = 3L) {
    .Call(`_scTenifoldKnk_tensorDecompositionCpp`, networkList, K, maxIter, maxError, nDecimal)
}

